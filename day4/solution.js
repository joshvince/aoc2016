/*
PART ONE
*/

function compose() {
  var funcs = arguments;
  return function() {
    var args = arguments;
    for (var i = funcs.length; i --> 0;) {
      args = [funcs[i].apply(this, args)];
    }
    return args[0];
  };
};

function solvePartOne(input) {
  return parseInput(input).reduce((acc,obj)=>{
    return compareChecksums(acc, obj)
  }, 0);
}

/*
turns the input string into objects that contain id, name and checksum KV pairs.
See doc for convertToObject/1 for details
*/
function parseInput(string) {
  // remember, these get applied right-to-left
  var f = compose(createObjects, splitOnDashes, createArrays)
  return f(string)
}

function createArrays(string){
  return string.split('\n')
}

function splitOnDashes(arrays){
  return arrays.map(str=>{
    return str.split("-")
  })
}

function createObjects(array) {
  return array.map(arr=>{
    return convertToObject(arr)
  })
}

/*
Does the heavy lifting turning:
['not','a','real','room','404[oarel]'] into:
{id: 404, checksum: oarel, name: 'notarealroom'}
Most of the magic splitting and slicing is to get rid of the square brackets provided by the aoc input
*/
function convertToObject(array) {
  var idchecksum = array.pop().split('[');
  var id = parseInt(idchecksum[0])
  var checksum = idchecksum[1].slice(0,-1)
  var name = array.join("")
  return {
    id: id,
    checksum: checksum,
    name: name
  }
}

/*
checks whether the checksum is equal to the checksum candidate generated by processName/1.
If they match, it adds this object's id to the accumulator and returns it.
This function is designed to be called inside Array.reduce
*/
function compareChecksums(acc, obj) {
  if (processName(obj.name) == obj.checksum) {
    acc += obj.id
  }
  return acc
}

/*
calls all the functions to turn a name string into a checksum candidate, ready to be compared with the given checksum.
See the docs for each individual function in compose() for details
*/
function processName(string){
  // remember: these functions get called right to left
  var f = compose(getChecksum, sortByLongest, splitAndSquash, toSortedArray)
  return f(string)
}

/*
splits apart each letter of the string and sorts them alphabetically to group occurrences of each letter
*/
function toSortedArray(string){
  return string.split("").sort();
}

/* 
See squashLettersTogether/3 for what this does 
*/
function splitAndSquash(array){
  var init = array.shift();
  return squashLettersTogether([], init, array)
}

/* 
Recurses through the array checking if each element is the same letter as the last.
If it's the same, it concats all instances of that letter into a string like this 'aaaa'
It returns an array of strings that are all the same letter, like this: ['aaaa', 'bb']
*/
function squashLettersTogether(acc, currentString, array){
  if (array.length === 0) {
    acc.push(currentString)
    return acc
  }
  else {
    var element = array.shift();
    if (element === currentString[0]) {
      var newString = currentString.concat(element);
      return squashLettersTogether(acc, newString, array)
    }
    else {
      acc.push(currentString)
      return squashLettersTogether(acc, element, array)
    }
  }  
}

/*
sorts the ['aaaa', 'bbb'] arrays by longest (ie: most frequent) first, and then by alphabetisation if there is a tie.
*/
function sortByLongest(array) {
  return array.sort((a,b)=>{ 
    return b.length - a.length || a.localeCompare(b) 
  })
}

/*
given an pre-sorted array like ['aaaa','bbb' etc], takes the first five (the five most frequent) letters
chops off just one letter rather than lots of them.
joins the letters together to create a string that will be a checksum candidate.
*/
function getChecksum(array) {
  return array.slice(0,5).map(str=>{ return str[0] }).join("")
}

module.exports = {
  solvePartOne: solvePartOne
}
